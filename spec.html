<!DOCTYPE html>
<meta charset="utf-8">
<pre class="metadata">
title: Integer
status: proposal
stage: 1
location: https://github.com/littledan/proposal-integer
copyright: false
contributors: Daniel Ehrenberg, Brendan Eich
</pre>
<style>
emu-issue, emu-todo, emu-motivation, emu-my-example, emu-integration-plans {
    margin: 1em 0;
    padding: .5em;
    padding-left: 1em;
    display: block;
}

emu-issue:before, emu-todo:before, emu-motivation:before, emu-my-example:before, emu-integration-plans:before {
    display: block;
    padding-bottom: .5em;
    margin-left: -.5em;
}

emu-issue {
    border-left: 5px solid #ff0000;
    background: #ffdddd;
}

emu-issue:before {
    color: #770000;
    content: "ISSUE";
}

emu-motivation {
    border-left: 5px solid #aaaa00;
    background: #ffffdd;
}

emu-motivation:before {
    color: #666600;
    content: "MOTIVATION";
}

emu-todo {
    border-left: 5px solid #00aa00;
    background: #ddffdd;
}

emu-todo:before {
    color: #006600;
    content: "TODO";
}

emu-my-example {
    border-left: 5px solid #0000aa;
    background: #ddddff;
}

emu-my-example:before {
    color: #000066;
    content: "EXAMPLE";
}

emu-integration-plans {
    border-left: 5px solid #aa00aa;
    background: #ffddff;
}

emu-integration-plans:before {
    color: #660066;
    content: "INTEGRATION PLANS";
}
</style>

<emu-intro id="sec-intro">
  <h1>Introduction</h1>
<p>This proposal adds arbitrary-precision integers to ECMAScript. For motivation and a high-level introduction, see <a href="https://github.com/littledan/proposal-integer/blob/master/README.md">the explainer document</a>.</p>

<emu-integration-plans>
  <p>I attempted to write this specification draft with an eye towards intelligiblity and clarifying issues, rather than looking exactly like the final specification. In particular, the translation of the operations on the Number type into the new form are omitted, as they are identical to the previous definitions and would be expressed only as a lengthy refactoring to skip when reading this text.</p>
  <p>If you find any part of this specification unclear or confusing, please <a href="https://github.com/littledan/proposal-integer/issues/new">file an issue</a>.</p>
</emu-integration-plans>
</emu-intro>
<emu-clause id="sec-numeric-types">
  <h1>Numeric Types</h1>
  <emu-issue>This specification introduces a protocol to help describe overloading of built-in operators to work on both Numbers and Integers. An <a href="https://github.com/littledan/proposal-integer/issues/12">alternative</a> would be to simply inline the new Integer definition alongside the old Number definition in an ad-hoc way.</a></emu-issue>
  <p>ECMAScript has two built-in numeric types: Number two Integer. In this specification, every numeric type _T_ contains an additive identity value denoted _T_::additiveZero and a multiplicative identity value denoted _T_::unit. The specification types also have the following abstract operations, likewise denoted _T_::<i>op</i> for a given operation with specification name <i>op</i>. Unless noted otherwise, argument and result types are all _T_.</p>
  <emu-table id="table-numeric-type-ops" caption="Numeric Type Operations">
    <table>
      <tbody>
      <tr>
        <th>
          Invocation Synopsis
        </th>
        <th>
          Value and Purpose
        </th>
      </tr>
      <tr>
        <td>
          _T_::unaryMinus(x)
        </td>
        <td>
          A specification function invoked when applying the unary minus operator. Called by the semantics of the <emu-xref href="#sec-unary-minus-operator">unary - operator</emu-xref>.
        </td>
      </tr>
      <tr>
        <td>
          _T_::bitwiseNOT(x)
        </td>
        <td>
          A specification function invoked when applying the bitwise NOT operator. Called by the semantics of the <emu-xref href="#sec-bitwise-not-operator">bitwise NOT operator</emu-xref> for `~x`.
        </td>
      </tr>
      <tr>
        <td>
          _T_::exponentiate(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying the exponentiation operator. Called by the semantics of the <emu-xref href="#sec-exp-operator">exponentiation operator</emu-xref> for `x ** y`.
        </td>
      </tr>
      <tr>
        <td>
          _T_::multiply(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying the multiplication operator. Called by the semantics of the <emu-xref href="#sec-applying-the-mul-operator">`*` operator</emu-xref> for `x * y`.
        </td>
      </tr>
      <tr>
        <td>
          _T_::divide(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying the division operator. Called by the semantics of the <emu-xref href="#sec-applying-the-div-operator">`/` operator</emu-xref> for `x / y`.
        </td>
      </tr>
      <tr>
        <td>
          _T_::remainder(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying the truncating remainder ("mod") operator. Called by the semantics of the <emu-xref href="#sec-applying-the-mod-operator">`%` operator</emu-xref> for `x % y`.
          <emu-todo>Revist this name, as Number::remainder explicitly doesn't do the IEEE 754 remainder operation.</emu-todo>
        </td>
      </tr>
      <tr>
        <td>
          _T_::add(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying the addition operator. Called by the semantics of the <emu-xref href="#sec-addition-operator-plus">`+` operator</emu-xref> for `x + y`.
        </td>
      </tr>
      <tr>
        <td>
          _T_::subtract(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying the subtraction operator. Called by the semantics of the <emu-xref href="#sec-subtraction-operator-minus">`-` operator</emu-xref> for `x - y`.
        </td>
      </tr>
      <tr>
        <td>
          _T_::leftShift(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying the left shift operator to two operands, the left one of type _T_ and the right one converted from any type into a shift amount. Called by the semantics of the <emu-xref href="#sec-left-shift-operator">`<<` operator</emu-xref> for `x << y`.
        </td>
      </tr>
      <tr>
        <td>
          _T_::signedRightShift(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying the right shift operator to two operands, the left one of type _T_ and the right one converted from any type into a shift amount. Called by the semantics of the <emu-xref href="#sec-signed-right-shift-operator">`>>` operator</emu-xref> for `x >> y`.
        </td>
      </tr>
      <tr>
        <td>
          _T_::unsignedRightShift(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying the right shift operator to two operands, the left one of type _T_ and the right one converted from any type into a shift amount. Called by the semantics of the <emu-xref href="#sec-unsigned-right-shift-operator">`>>>` operator</emu-xref> for `x >>> y`.
        </td>
      </tr>
      <tr>
        <td>
          _T_::lessThan(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying one of the four partial-order <emu-xref href="#sec-relational-operators">relational operators</emu-xref>. The return value must be *false*, *true*, or *undefined* (for unordered inputs). Called by the <emu-xref href="#sec-abstract-relational-comparison">Abstract Relational Comparison</emu-xref> algorithm for `x < y`, `x > y`, `x <= y`, and `x >= y`.
        </td>
      </tr>
      <tr>
        <td>
          _T_::equal(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying <emu-xref href="#sec-equality-operators">equality operators</emu-xref>. The return value must be *false* or *true*. Called by the <emu-xref href="#sec-strict-equality-comparison">Strict Equality Comparison</emu-xref> algorithm for `x == y`, `x != y`, `x === y`, and `x !== y`.
        </td>
      </tr>
      <tr>
        <td>
          _T_::sameValue(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying <emu-xref href="#sec-samevalue">abstract operation SameValue</emu-xref>. The return value must be *false* or *true*. Called from Object internal methods to test exact value equality.
        </td>
      </tr>
      <tr>
        <td>
          _T_::sameValueZero(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying <emu-xref href="#sec-samevaluezero">abstract operation SameValueZero</emu-xref>. The return value must be *false* or *true*. Called from Array, Map, and Set methods to test value equality ignoring differences among members of the zero cohort (e.g., *-0* and *+0*).
        </td>
      </tr>
      <tr>
        <td>
          _T_::bitwiseAND(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying <emu-xref href="#sec-binary-bitwise-operators">binary bitwise AND operator</emu-xref>. Called by the <emu-xref href="#sec-binary-bitwise-operators-runtime-semantics-evaluation">Binary Bitwise Operators</emu-xref> algorithm for `x &amp; y`.
        </td>
      </tr>
      <tr>
        <td>
          _T_::bitwiseXOR(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying <emu-xref href="#sec-binary-bitwise-operators">binary bitwise XOR operator</emu-xref>. Called by the <emu-xref href="#sec-binary-bitwise-operators-runtime-semantics-evaluation">Binary Bitwise Operators</emu-xref> algorithm for `x ^ y`.
        </td>
      </tr>
      <tr>
        <td>
          _T_::bitwiseOR(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying <emu-xref href="#sec-binary-bitwise-operators">binary bitwise OR operator</emu-xref>. Called by the <emu-xref href="#sec-binary-bitwise-operators-runtime-semantics-evaluation">Binary Bitwise Operators</emu-xref> algorithm for `x | y`.
        </td>
      </tr>
      </tbody>
    </table>
  </emu-table>
  <p>The _T_::additiveZero value, _T_::unit value, and _T_::_op_ operations are not a part of the ECMAScript language; they are defined here solely to aid the specification of the semantics of the ECMAScript language. Other abstract operations are defined throughout this specification.</p>
  <p>Because the numeric types are in general not interconvertible without loss of precision or truncation, the ECMAScript language provides no implicit conversion among these types. Programmers must explicitly call `Number` and `Integer` functions to convert among types when calling a function which requires another type.</p>
  <emu-integration-plans>Number::additiveZero is *-0*.</emu-integration-plans>
  <emu-note>
   <p>The first and subsequent editions of ECMAScript have provided, for certain operators, implicit numeric conversions that could lose precision or truncate. These legacy implicit conversions are maintained for backward compatibility, but not provided for Integer in order to minimize opportunity for programmer error, and to leave open the option of generalized <em>value types</em> in a future edition.</p>
  </emu-note>


  <emu-clause id="sec-ecmascript-language-types-integer-type">
   <h1>The Integer Type</h1>
   <p>The Integer type represents a mathematical integer value. The value may be any size and is not limited to a particular bit-width. Generally, where not otherwise noted, operations are designed to return exact mathematically-based answers. For binary operations, Integers act as two's complement binary strings, with negative numbers treated as having bits set infinitely to the left.</p>

   <p>The Integer::additiveZero value is *0n*.</p>
   <p>The Integer::unit value is *1n*.</p>

    <emu-clause id="sec-numeric-types-integer-unaryMinus">
      <h1>Integer::unaryMinus (_x_)</h1>
      <p>The abstract operation Integer::unaryMinus with an argument _x_ of Integer type returns the result of negating _x_; that is, compute an Integer with the same magnitude but opposite sign.</p>
    </emu-clause>

    <emu-clause id="sec-numeric-types-integer-bitwiseNOT">
      <h1>Integer::bitwiseNOT (_x_)</h1>
      <p>The abstract operation Integer::bitwiseNOT with an argument _x_ of Integer type returns the one's complement of _x_; that is, -_x_ - 1.</p>
    </emu-clause>

    <emu-clause id="sec-numeric-types-integer-exponentiate">
      <h1>Integer::exponentiate (_base_, _exponent_)</h1>
      <emu-alg>
        1. If _exponent_ &lt; 0, throw a *RangeError* exception.
        1. If SameValue(_base_, *0n*) and Samevalue(_exponent_, *0n*), return *1n*.
        1. Return an Integer representing the mathematical value of _base_ raised to the power _exponent_.
      </emu-alg>
      <emu-issue>
        See <a href="https://github.com/littledan/proposal-integer/issues/9">Issue #9</a> discussion about exception throwing semantics. An alternative would be to return 0 here.
      </emu-issue>
    </emu-clause>

    <emu-clause id="sec-numeric-types-integer-multiply">
      <h1>Integer::multiply (_x_, _y_)</h1>
      <p>The abstract operation Integer::multiply with two arguments _x_ and _y_ of Integer type returns an Integer representing the result of multiplying _x_ and _y_.</p>
      <emu-note>Even if the result has a much larger bit width than the input, the exact mathematical answer is given.</emu-note>
    </emu-clause>

    <emu-clause id="sec-numeric-types-integer-divide">
      <h1>Integer::divide (_x_, _y_)</h1>
      <emu-alg>
        1. If SameValue(_y_, *0n*), throw a *RangeError* exception.
        1. Let _quotient_ be the mathematical value of _x_ divided by _y_.
        1. Return an Integer representing _quotient_ rounded towards 0 to the next integral value.
      </emu-alg>
      <emu-issue>
        See <a href="https://github.com/littledan/proposal-integer/issues/7">Issue #7</a> discussion about exception throwing semantics.
      </emu-issue>
    </emu-clause>

    <emu-clause id="sec-numeric-types-integer-remainder">
      <h1>Integer::remainder (_x_, _y_)</h1>
      <emu-alg>
        1. If _y_ is `0n`, throw a *RangeError* exception.
        1. Return the Integer representing <emu-eqn>_x_ modulo _y_</emu-eqn>.
      </emu-alg>
      <emu-todo>Revisit/double-check the specification of these semantics--the result here should be analogous to Number::remainder with respect to sign.</emu-todo>
    </emu-clause>

    <emu-clause id="sec-numeric-types-integer-add">
      <h1>Integer::add (_x_, _y_)</h1>
      <p>The abstract operation Integer::add with two arguments _x_ and _y_ of Integer type returns an Integer representing the sum of _x_ and _y_.</p>
    </emu-clause>

    <emu-clause id="sec-numeric-types-integer-subtract">
      <h1>Integer::subtract (_x_, _y_)</h1>
      <p>The abstract operation Integer::subtract with two arguments _x_ and _y_ of Integer type returns the Integer representing the difference _x_ minus _y_.</p>
    </emu-clause>

    <emu-clause id="sec-numeric-types-integer-leftShift">
      <h1>Integer::leftShift (_x_, _y_)</h1>
      <p>The abstract operation Integer::leftShift with two arguments _x_ and _y_ of Integer:</p>
      <emu-alg>
        1. If _y_ &lt; 0,
          1. Return an Integer representing _x_ divided by 2<sup>_y_</sup>, rounding down to the nearest integer, including for negative numbers.
        1. Return an Integer representing _x_ multiplied by 2<sup>_y_</sup>.
      </emu-alg>
      <emu-note>Semantics here should be equivalent to a bitwise shift, treating the Integer as an infinite length string of binary two's complement digits.</emu-note>
      <emu-issue>
        Semantics here differ a bit from Number; see <a href="https://github.com/littledan/proposal-integer/issues/8">Issue #8</a> for details.
      </emu-issue>
    </emu-clause>

    <emu-clause id="sec-numeric-types-integer-signedRightShift">
      <h1>Integer::signedRightShift (_x_, _y_)</h1>
      <p>The abstract operation Integer::signedRightShift with arguments _x_ of Integer type and _y_ of any type:</p>
      <emu-alg>
        1. Return ? Integer::leftShift(_x_, -_y_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-numeric-types-integer-unsignedRightShift">
      <h1>Integer::unsignedRightShift (_x_, _y_)</h1>
      <p>The abstract operation Integer::unsignedRightShift with two arguments _x_ of Integer type and _y_ of any type:</p>
      <emu-alg>
        1. Throw a *TypeError* exception.
      </emu-alg>
      <emu-issue>
        See <a href="https://github.com/littledan/proposal-integer/issues/6">Issue #6</a> for background and discussion about unsigned signed right shift semantics. An alternative here would be to return the signed shift result.
      </emu-issue>
    </emu-clause>

    <emu-clause id="sec-numeric-types-integer-lessThan">
      <h1>Integer::lessThan (_x_, _y_)</h1>
      <p>The abstract operation Integer::lessThan with two arguments _x_ and _y_ of Integer type returns *true* if _x_ is less than _y_ and *false* otherwise.</p>
    </emu-clause>

    <emu-clause id="sec-numeric-types-integer-equal">
      <h1>Integer::equal (_x_, _y_)</h1>
      <p>The abstract operation Integer::equal with two arguments _x_ and _y_ of Integer type returns *true* if _x_ and _y_ have the same mathematical integer value and *false* otherwise.</p>
    </emu-clause>

    <emu-clause id="sec-numeric-types-integer-sameValue">
      <h1>Integer::sameValue (_x_, _y_)</h1>
      <p>The abstract operation Integer::sameValue with two arguments _x_ and _y_ of Integer type:</p>
      <emu-alg>
        1. Return Integer::equal(_x_, _y_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-numeric-types-integer-sameValueZero">
      <h1>Integer::sameValueZero (_x_, _y_)</h1>
      <p>The abstract operation Integer::sameValueZero with two arguments _x_ and _y_ of Integer type:</p>
      <emu-alg>
        1. Return Integer::equal(_x_, _y_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-bitwise-op">
      <h1>BitwiseOp(_op_, _x_, _y_)</h1>
      <emu-alg>
        1. Let _result_ be 0.
        1. Let _shift_ be 0.
        1. Repeat, until (_x_ = 0 or _x_ = -1) and (_y_ = 0 or _y_ = -1),
          1. Let _xDigit_ be _x_ modulo 2.
          1. Let _yDigit_ be _y_ modulo 2.
          1. Let _result_ be result + 2<sup>_shift_</sup> * op(_xDigit_, _yDigit_)
          1. Let _shift_ be _shift_ + 1.
          1. Let _x_ be (_x_ - _xDigit_) / 2.
          1. Let _y_ be (_y_ - _yDigit_) / 2.
        1. If _op_(_x_ modulo 2, _y_ modulo 2) &ne; 0,
          1. Let _result_ be _result_ - 2<sup>_shift_</sup>. NOTE: This extends the sign.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-numeric-types-integer-bitwiseAND">
      <h1>Integer::bitwiseAND (_x_, _y_)</h1>
      <emu-alg>
        1. Return BitwiseOp(`&amp;`, _x_, _y_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-numeric-types-integer-bitwiseXOR">
      <h1>Integer::bitwiseXOR (_x_, _y_)</h1>
      <emu-alg>
        1. Return BitwiseOp(`^`, _x_, _y_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-numeric-types-integer-bitwiseOR">
      <h1>Integer::bitwiseOR (_x_, _y_)</h1>
      <emu-alg>
        1. Return BitwiseOp(`|`, _x_, _y_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-integration-plans>
    As part of the integration with the main specification, the Number type will have a similar definition of operations, derived from the current operator definitions. Because the semantics are not proposed to change, for ease of review, the refactoring is omitted from this spec draft.
  </emu-integration-plans>
</emu-clause>

<emu-clause id="sec-grammar-change">
  <h1>Modifications to the Number grammar</h1>
  <emu-grammar>
    NumericLiteral ::
      <del>DecimalLiteral</del>
      <del>BinaryIntegerLiteral</del>
      <del>OctalIntegerLiteral</del>
      <del>HexIntegerLiteral</del>
      <ins>NumericLiteralBase</ins>
      <ins>NumericLiteralBase NumericLiteralSuffix</ins>
      LegacyOctalIntegerLiteral

    <ins>NumericLiteralBase ::
          DecimalLiteral
          BinaryIntegerLiteral
          OctalIntegerLiteral
          HexIntegerLiteral</ins>

    <ins>NumericLiteralSuffix :: `n`</ins>
  </emu-grammar>
  <emu-issue>Which letter suffix should be used is <a href="https://github.com/littledan/proposal-integer/issues/1">under discussion</a>; other contenders include `L`, `N`, `I` or `i`</emu-issue>

  <emu-clause id="sec-numeric-literal-static-semantics-early-errors">
    <h1>Static Semantics: Early Errors</h1>
    <emu-grammar>NumericLiteral :: NumericLiteralBase NumericLiteralSuffix</emu-grammar>
    <ul>
      <li>
        It is a Syntax Error if the MV is not an integer.
      </li>
      <li>
        It is a Syntax Error if the |NumericLiteralBase| contains an |ExponentPart|.
      </li>
    </ul>
  </emu-clause>

  <emu-clause id="sec-numeric-literal-static-semantics-integer-value">
    <h1>Static Semantics: Integer Value</h1>
    <emu-grammar>NumericLiteral :: NumericLiteralBase NumericLiteralSuffix</emu-grammar>
    <ul>
      <li>Assert: |NumericLiteralSuffix| is `n`.</li>
      <li>
        Let the value of |NumericLiteral| be the MV of |NumericLiteralBase| represented as Integer.
      </li>
    </ul>
  </emu-clause>

   <emu-clause id="sec-numeric-literal-static-semantics-number-value">
     <h1>Static Semantics: Number Value</h1>
     <emu-grammar>NumericLiteral :: NumericLiteralBase</emu-grammar>
       <p>The MV is rounded to a value of the Number type.</p>
    </emu-clause>

    <emu-integration-plans>
      Rounding to the nearest Number will be moved from the MV calcuation to a Number Value Static Semantics section so that it doesn't apply to Integers.
    </emu-integration-plans>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-abstract-operations">
  <h1>Abstract Operations</h1>
  <emu-clause id="sec-type-conversion">
     <h1>Type Conversion</h1>
     The Integer type has no implicit conversions in the ECMAScript language; programmers must call Integer explicitly to convert values from other types.

    <emu-clause id="sec-toprimitive" aoid="ToPrimitive">
      <h1>ToPrimitive ( _input_ [ , _PreferredType_ ] )</h1>
      <emu-table id="table-9" caption="ToPrimitive Conversions">
        <table>
          <tbody>
          <tr>
            <th>
              Input Type
            </th>
            <th>
              Result
            </th>
          </tr>
          <tr>
            <td>
              <ins>Integer</ins>
            </td>
            <td>
              <ins>Return _input_.</ins>
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-toboolean" aoid="ToBoolean">
      <h1>ToBoolean ( _argument_ )</h1>
      <p>The abstract operation ToBoolean converts _argument_ to a value of type Boolean according to <emu-xref href="#table-10"></emu-xref>:</p>
      <emu-table id="table-10" caption="ToBoolean Conversions">
        <table>
          <tbody>
          <tr>
            <th>
              Argument Type
            </th>
            <th>
              Result
            </th>
          </tr>
          <tr>
            <td>
              <ins>Integer</ins>
            </td>
            <td>
              <ins>Return *false* if _argument_ is *0n*; otherwise return *true*.</ins>
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
      <emu-issue>
        Are these semantics overkill? One alternative under discussion is to <a href="https://github.com/littledan/proposal-integer/issues/11">return false</a>.
      </emu-issue>
    </emu-clause>

    <emu-clause id="sec-tonumber" aoid="ToNumber">
      <h1>ToNumber ( _argument_ )</h1>
      <p>The abstract operation ToNumber converts _argument_ to a value of type Number according to <emu-xref href="#table-11"></emu-xref>:</p>
      <emu-table id="table-11" caption="ToNumber Conversions">
        <table>
          <tbody>
          <tr>
            <th>
              Argument Type
            </th>
            <th>
              Result
            </th>
          </tr>
          <tr>
            <td>
              <ins>Integer</ins>
            </td>
            <td>
              <ins>Throw a *TypeError* exception</ins>
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
      <emu-motivation>
        Although it would be possible to define a conversion here, to find the nearest Number for an Integer, such a conversion may lose precision. ToNumber is called implicitly from so many places, but Integers would not add any value if they lost precision all the time; you might as well just use Numbers instead in the first place. A key <a href="https://github.com/littledan/proposal-integer/blob/master/README.md#no-implicit-conversions-or-mixed-operands">design decision</a> of this specification is to disallow implicit conversions, and force programmers to to explicit conversions themselves instead.
      </emu-motivation>

      <emu-clause id="sec-tonumber-applied-to-the-string-type">
        <h1>ToNumber Applied to the String Type</h1>
        <emu-note>
          <p>Some differences should be noted between the syntax of a |StringNumericLiteral| and a |NumericLiteral|:</p>
            <li>
              <ins>A |StringNumericLiteral| may not include a |NumericLiteralSuffix|.</ins>
            </li>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-tostring" aoid="ToString">
      <h1>ToString ( _argument_ )</h1>
      <p>The abstract operation ToString converts _argument_ to a value of type String according to <emu-xref href="#table-12"></emu-xref>:</p>
      <emu-table id="table-12" caption="ToString Conversions">
        <table>
          <tbody>
          <tr>
            <th>
              Argument Type
            </th>
            <th>
              Result
            </th>
          </tr>
          <tr>
            <td>
              Integer
            </td>
            <td>
              See <emu-xref href="#sec-tostring-applied-to-the-integer-type"></emu-xref>.
            </td>
          </tr>
          </tbody>
        </table>
       </emu-table>

      <emu-clause id="sec-tostring-applied-to-the-integer-type" aoid="ToString Applied to the Integer Type">
        <h1>ToString Applied to the Integer Type</h1>
        <p>The abstract operation ToString converts an Integer _i_ to String format as follows:</p>
        <emu-alg>
          1. If _i_ is less than zero, return the String concatenation of the String `"-"` and ToString(-_i_).
          1. Return the String consisting of the code units of the digits of the decimal representation of _i_.
        </emu-alg>
        <emu-issue>ToString may concatenate `n` on the end; see <a href="https://github.com/littledan/proposal-integer/issues/5">discussion</a></emu-issue>
      </emu-clause>
     </emu-clause>

    <emu-clause id="sec-toobject" aoid="ToObject">
      <h1>ToObject ( _argument_ )</h1>
      <p>The abstract operation ToObject converts _argument_ to a value of type Object according to <emu-xref href="#table-13"></emu-xref>:</p>
      <emu-table id="table-13" caption="ToObject Conversions">
        <table>
          <tbody>
          <tr>
            <th>
              Argument Type
            </th>
            <th>
              Result
            </th>
          </tr>
          <tr>
            <td>
              <ins>Integer</ins>
            </td>
            <td>
              <ins>Return a new Integer object whose [[IntegerData]] internal slot is set to _argument_. See <a href="#sec-integer-objects">Integer Objects</a> for a description of Integer objects.</ins>
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-tonumeric" aoid="ToNumeric">
      <h1>ToNumeric ( _value_ )</h1>
      <p>The abstract operation ToNumeric returns _value_ converted to a numeric value of type Number or Integer. This abstract operation functions as follows:</p>
      <emu-alg>
        1. Let _primValue_ be ? ToPrimitive(_value_, hint Number).
        1. If Type(_value_) is Integer, return _value_.
        1. Return ToNumber(_value_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-requireobjectcoercible" aoid="RequireObjectCoercible">
      <h1>RequireObjectCoercible ( _argument_ )</h1>
      <p>The abstract operation RequireObjectCoercible throws an error if _argument_ is a value that cannot be converted to an Object using ToObject. It is defined by <emu-xref href="#table-14"></emu-xref>:</p>
      <emu-table id="table-14" caption="RequireObjectCoercible Results">
        <table>
          <tbody>
          <tr>
            <th>
              Argument Type
            </th>
            <th>
              Result
            </th>
          </tr>
          <tr>
            <td>
              Integer
            </td>
            <td>
              Return _argument_.
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-testing-and-comparison-operations">
    <h1>Testing and Comparison Operations</h1>
    <emu-clause id="sec-samevalue" aoid="SameValue">
      <h1>SameValue ( _x_, _y_ )</h1>
       <p>The internal comparison abstract operation SameValue(_x_, _y_), where _x_ and _y_ are ECMAScript language values, produces *true* or *false*. Such a comparison is performed as follows:</p>
       <emu-alg>
         1. If Type(_x_) is different from Type(_y_), return *false*.
         1. If Type(_x_) is Number <ins>or Integer</ins>, then
           1. <del>If _x_ is *NaN* and _y_ is *NaN*, return *true*.</del>
           1. <del>If _x_ is *+0* and _y_ is *-0*, return *false*.</del>
           1. <del>If _x_ is *-0* and _y_ is *+0*, return *false*.</del>
           1. <del>If _x_ is the same Number value as _y_, return *true*.</del>
           1. <del>Return *false*.</del>
           1. <ins>Return ? Type(_x_)::sameValue(_x_, _y_).</ins>
         1. Return <a href="sec-samevaluenonnumber">SameValueNon<del>Number</del><ins>Numeric</ins></a>(_x_, _y_).
       </emu-alg>
       <emu-integration-plans>The previous Number-related contents of this algorithm will be moved into Number::sameValue.</emu-integration-plans>
    </emu-clause>

    <!-- es6num="7.2.10" -->
    <emu-clause id="sec-samevaluezero" aoid="SameValueZero">
      <h1>SameValueZero ( _x_, _y_ )</h1>
       <p>The internal comparison abstract operation SameValueZero(_x_, _y_), where _x_ and _y_ are ECMAScript language values, produces *true* or *false*. Such a comparison is performed as follows:</p>
       <emu-alg>
         1. If Type(_x_) is different from Type(_y_), return *false*.
         1. If Type(_x_) is Number <ins>or Integer</ins>, then
           1. <del>If _x_ is *NaN* and _y_ is *NaN*, return *true*.</del>
           1. <del>If _x_ is *+0* and _y_ is *-0*, return *true*.</del>
           1. <del>If _x_ is *-0* and _y_ is *+0*, return *true*.</del>
           1. <del>If _x_ is the same Number value as _y_, return *true*.</del>
           1. <del>Return *false*.</del>
           1. <ins>Return ? Type(_x_)::sameValueZero(_x_, _y_).</ins>
         1. Return <a href="sec-samevaluenonnumber">SameValueNon<del>Number</del><ins>Numeric</ins></a>(_x_, _y_).
       </emu-alg>
     </emu-clause>

    <emu-clause id="sec-samevaluenonnumber" aoid="SameValueNonNumeric">
      <h1>SameValueNon<del>Number</del><ins>Numeric</ins> ( _x_, _y_ )</h1>
      <p>The internal comparison abstract operation SameValueNonNumeric(_x_, _y_), where neither _x_ nor _y_ are numeric type values, produces *true* or *false*. Such a comparison is performed as follows:</p>
       <emu-alg>
         1. Assert: Type(_x_) is not Number <ins>or Integer</ins>.
         1. Assert: Type(_x_) is the same as Type(_y_).
         1. If Type(_x_) is Undefined, return *true*.
         1. If Type(_x_) is Null, return *true*.
         1. If Type(_x_) is String, then
           1. If _x_ and _y_ are exactly the same sequence of code units (same length and same code units at corresponding indices), return *true*; otherwise, return *false*.
         1. If Type(_x_) is Boolean, then
           1. If _x_ and _y_ are both *true* or both *false*, return *true*; otherwise, return *false*.
         1. If Type(_x_) is Symbol, then
           1. If _x_ and _y_ are both the same Symbol value, return *true*; otherwise, return *false*.
         1. Return *true* if _x_ and _y_ are the same Object value. Otherwise, return *false*.
      </emu-alg>
    </emu-clause>

    <!-- es6num="7.2.11" -->
    <emu-clause id="sec-abstract-relational-comparison" aoid="Abstract Relational Comparison">
      <h1>Abstract Relational Comparison</h1>
      <p>The comparison _x_ &lt; _y_, where _x_ and _y_ are values, produces *true*, *false*, or *undefined* (which indicates that at least one operand is *NaN*). In addition to _x_ and _y_ the algorithm takes a Boolean flag named _LeftFirst_ as a parameter. The flag is used to control the order in which operations with potentially visible side-effects are performed upon _x_ and _y_. It is necessary because ECMAScript specifies left to right evaluation of expressions. The default value of _LeftFirst_ is *true* and indicates that the _x_ parameter corresponds to an expression that occurs to the left of the _y_ parameter's corresponding expression. If _LeftFirst_ is *false*, the reverse is the case and operations must be performed upon _y_ before _x_. Such a comparison is performed as follows:</p>
      <emu-alg>
        1. If the _LeftFirst_ flag is *true*, then
          1. Let _px_ be ? ToPrimitive(_x_, hint Number).
          1. Let _py_ be ? ToPrimitive(_y_, hint Number).
        1. Else the order of evaluation needs to be reversed to preserve left to right evaluation,
          1. Let _py_ be ? ToPrimitive(_y_, hint Number).
          1. Let _px_ be ? ToPrimitive(_x_, hint Number).
        1. If both _px_ and _py_ are Strings, then
          1. If _py_ is a prefix of _px_, return *false*. (A String value _p_ is a prefix of String value _q_ if _q_ can be the result of concatenating _p_ and some other String _r_. Note that any String is a prefix of itself, because _r_ may be the empty String.)
          1. If _px_ is a prefix of _py_, return *true*.
          1. Let _k_ be the smallest nonnegative integer such that the code unit at index _k_ within _px_ is different from the code unit at index _k_ within _py_. (There must be such a _k_, for neither String is a prefix of the other.)
          1. Let _m_ be the integer that is the code unit value at index _k_ within _px_.
          1. Let _n_ be the integer that is the code unit value at index _k_ within _py_.
          1. If _m_ &lt; _n_, return *true*. Otherwise, return *false*.
        1. Else,
          1. <ins>Let _nx_ be ? ToNumeric(_px_). Because _px_ and _py_ are primitive values evaluation order is not important.</ins>
          1. <del>Let _nx_ be ? ToNumber(_px_). Because _px_ and _py_ are primitive values evaluation order is not important.</del>
          1. <del>Let _ny_ be ? ToNumber(_py_).</del>
          1. <del>If _nx_ is *NaN*, return *undefined*.</del>
          1. <del>If _ny_ is *NaN*, return *undefined*.</del>
          1. <del>If _nx_ and _ny_ are the same Number value, return *false*.</del>
          1. <del>If _nx_ is *+0* and _ny_ is *-0*, return *false*.</del>
          1. <del>If _nx_ is *-0* and _ny_ is *+0*, return *false*.</del>
          1. <del>If _nx_ is *+&infin;*, return *false*.</del>
          1. <del>If _ny_ is *+&infin;*, return *true*.</del>
          1. <del>If _ny_ is *-&infin;*, return *false*.</del>
          1. <del>If _nx_ is *-&infin;*, return *true*.</del>
          1. <del>If the mathematical value of _nx_ is less than the mathematical value of _ny_ &mdash;note that these mathematical values are both finite and not both zero&mdash;return *true*. Otherwise, return *false*.</del>
          1. <ins>Let _ny_ be ? ToNumeric(_py_).</ins>
          1. <ins>if Type(_nx_) is not Type(_ny_), throw a *TypeError* exception.</ins>
          1. <ins>Return ? Type(_nx_)::lessThan(_nx_, _ny_).</ins>
      </emu-alg>
       <emu-integration-plans>The previous Number-related contents of this algorithm will be moved into Number::lessThan.</emu-integration-plans>
      <emu-issue>In this section, comparisons between Integers and Numbers would throw a TypeError. A possible alternative semantics would be to permit comparisons; this is discussed <a href="https://github.com/littledan/proposal-integer/issues/4">in Issue #4</a>.</emu-issue>
    </emu-clause>

    <!-- es6num="7.2.12" -->
    <emu-clause id="sec-abstract-equality-comparison" aoid="Abstract Equality Comparison">
      <h1>Abstract Equality Comparison</h1>
      <p>The comparison _x_ == _y_, where _x_ and _y_ are values, produces *true* or *false*. Such a comparison is performed as follows:</p>
      <emu-alg>
        1. If Type(_x_) is the same as Type(_y_), then
          1. Return the result of performing Strict Equality Comparison _x_ === _y_.
        1. If _x_ is *null* and _y_ is *undefined*, return *true*.
        1. If _x_ is *undefined* and _y_ is *null*, return *true*.
        1. If Type(_x_) is Number and Type(_y_) is String, return the result of the comparison _x_ == ToNumber(_y_).
        1. If Type(_x_) is String and Type(_y_) is Number, return the result of the comparison ToNumber(_x_) == _y_.
        1. If Type(_x_) is Boolean, return the result of the comparison ToNumber(_x_) == _y_.
        1. If Type(_y_) is Boolean, return the result of the comparison _x_ == ToNumber(_y_).
        1. If Type(_x_) is either String, Number, or Symbol and Type(_y_) is Object, return the result of the comparison _x_ == ToPrimitive(_y_).
        1. If Type(_x_) is Object and Type(_y_) is either String, Number, or Symbol, return the result of the comparison ToPrimitive(_x_) == _y_.
        1. <ins>If Type(_x_) is Integer and Type(_y_) is Number, or if Type(_x_) is Number and Type(_y_) is Integer, throw a *TypeError* exception.</ins>
        1. Return *false*.
      </emu-alg>
      <emu-issue>In this section, comparisons between Integers and Numbers would throw a TypeError. A possible alternative semantics would be to permit comparisons; this is discussed <a href="https://github.com/littledan/proposal-integer/issues/4">in Issue #4</a>.</emu-issue>
    </emu-clause>

    <!-- es6num="7.2.13" -->
    <emu-clause id="sec-strict-equality-comparison" aoid="Strict Equality Comparison">
      <h1>Strict Equality Comparison</h1>
      <p>The comparison _x_ === _y_, where _x_ and _y_ are values, produces *true* or *false*. Such a comparison is performed as follows:</p>
      <emu-alg>
        1. If Type(_x_) is different from Type(_y_), return *false*.
        1. If Type(_x_) is Number <ins>or Integer</ins>, then
          1. <del>If _x_ is *NaN*, return *false*.</del>
          1. <del>If _y_ is *NaN*, return *false*.</del>
          1. <del>If _x_ is the same Number value as _y_, return *true*.</del>
          1. <del>If _x_ is *+0* and _y_ is *-0*, return *true*.</del>
          1. <del>If _x_ is *-0* and _y_ is *+0*, return *true*.</del>
          1. <del>Return *false*.</del>
          1. <ins>Return ? Type(_x_)::equal(_x_, _y_).</ins>
        1. Return <a href="sec-samevaluenonnumber">SameValueNon<del>Number</del><ins>Numeric</ins></a>(_x_, _y_).
      </emu-alg>
      <emu-integration-plans>The previous Number-related contents of this algorithm will be moved into Number::equal.</emu-integration-plans>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-expressions">
  <h1>ECMAScript Language: Expressions</h1>

  <emu-clause id="sec-update-expressions">
    <h1>Update Expressions</h1>

    <!-- es6num="12.4.4" -->
    <emu-clause id="sec-postfix-increment-operator">
      <h1>Postfix Increment Operator</h1>

      <!-- es6num="12.4.4.1" -->
      <emu-clause id="sec-postfix-increment-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UpdateExpression : LeftHandSideExpression `++`</emu-grammar>
        <emu-alg>
          1. Let _lhs_ be the result of evaluating |LeftHandSideExpression|.
          1. <del>Let _oldValue_ be ? ToNumber(? GetValue(_expr_)).</del>
          1. <del>Let _newValue_ be the result of adding the value 1 to _oldValue_, using the same rules as for the `+` operator (see <emu-xref href="#sec-applying-the-additive-operators-to-numbers"></emu-xref>).</del>
          1. <ins>Let _oldValue_ be ? ToNumeric(? GetValue(_lhs_)).</ins>
          1. <ins>Let _newValue_ be ? Type(_oldvalue_)::add(_oldValue_, Type(_oldValue_)::unit).</ins>
          1. Perform ? PutValue(_lhs_, _newValue_).
          1. Return _oldValue_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <!-- es6num="12.4.5" -->
    <emu-clause id="sec-postfix-decrement-operator">
      <h1>Postfix Decrement Operator</h1>

      <!-- es6num="12.4.5.1" -->
      <emu-clause id="sec-postfix-decrement-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UpdateExpression : LeftHandSideExpression `--`</emu-grammar>
        <emu-alg>
          1. Let _lhs_ be the result of evaluating |LeftHandSideExpression|.
          1. <del>Let _oldValue_ be ? ToNumber(? GetValue(_expr_)).</del>
          1. <del>Let _newValue_ be the result of subtracting the value 1 from _oldValue_, using the same rules as for the `-` operator (see <emu-xref href="#sec-applying-the-additive-operators-to-numbers"></emu-xref>).</del>
          1. <ins>Let _oldValue_ be ? ToNumeric(? GetValue(_lhs_)).</ins>
          1. <ins>Let _newValue_ be ? Type(_oldvalue_)::subtract(_oldValue_, Type(_oldValue_)::unit).</ins>
          1. Perform ? PutValue(_lhs_, _newValue_).
          1. Return _oldValue_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <!-- es6num="12.5.7" -->
    <emu-clause id="sec-prefix-increment-operator">
      <h1>Prefix Increment Operator</h1>

      <!-- es6num="12.5.7.1" -->
      <emu-clause id="sec-prefix-increment-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UpdateExpression : `++` UnaryExpression</emu-grammar>
        <emu-alg>
          1. Let _expr_ be the result of evaluating |UnaryExpression|.
          1. <del>Let _oldValue_ be ? ToNumber(? GetValue(_expr_)).</del>
          1. <del>Let _newValue_ be the result of adding the value 1 to _oldValue_, using the same rules as for the `+` operator (see <emu-xref href="#sec-applying-the-additive-operators-to-numbers"></emu-xref>).</del>
          1. <ins>Let _oldValue_ be ? ToNumeric(? GetValue(_lhs_)).</ins>
          1. <ins>Let _newValue_ be ? Type(_oldvalue_)::add(_oldValue_, Type(_oldValue_)::unit).</ins>
          1. Perform ? PutValue(_expr_, _newValue_).
          1. Return _newValue_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <!-- es6num="12.5.8" -->
    <emu-clause id="sec-prefix-decrement-operator">
      <h1>Prefix Decrement Operator</h1>

      <!-- es6num="12.5.8.1" -->
      <emu-clause id="sec-prefix-decrement-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UpdateExpression : `--` UnaryExpression</emu-grammar>
        <emu-alg>
          1. Let _expr_ be the result of evaluating |UnaryExpression|.
          1. <del>Let _oldValue_ be ? ToNumber(? GetValue(_expr_)).</del>
          1. <del>Let _newValue_ be the result of subtracting the value 1 from _oldValue_, using the same rules as for the `-` operator (see <emu-xref href="#sec-applying-the-additive-operators-to-numbers"></emu-xref>).</del>
          1. <ins>Let _oldValue_ be ? ToNumeric(? GetValue(_lhs_)).</ins>
          1. <ins>Let _newValue_ be ? Type(_oldvalue_)::subtract(_oldValue_, Type(_oldValue_)::unit).</ins>
          1. Perform ? PutValue(_expr_, _newValue_).
          1. Return _newValue_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
  <emu-clause id="sec-unary-operators">
    <h1>Unary Operators</h1>
    <!-- es6num="12.5.6" -->
    <emu-clause id="sec-typeof-operator">
      <h1>The `typeof` Operator</h1>

      <!-- es6num="12.5.6.1" -->
      <emu-clause id="sec-typeof-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UnaryExpression : `typeof` UnaryExpression</emu-grammar>
        <emu-table id="table-35" caption="typeof Operator Results">
          <table>
            <tbody>
            <tr>
              <th>
                Type of _val_
              </th>
              <th>
                Result
              </th>
            </tr>
            <tr>
              <td>
                <ins>Integer</ins>
              </td>
              <td>
                <ins>`"integer"`</ins>
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>

    <!-- es6num="12.5.9" -->
    <emu-clause id="sec-unary-plus-operator">
      <h1>Unary `+` Operator</h1>
      <emu-note>
        <p>The unary + operator converts its operand to Number type.</p>
      </emu-note>

      <!-- es6num="12.5.9.1" -->
      <emu-clause id="sec-unary-plus-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UnaryExpression : `+` UnaryExpression</emu-grammar>
        <emu-alg>
          1. Let _expr_ be the result of evaluating |UnaryExpression|.
          1. Return ? ToNumber(? GetValue(_expr_)).
        </emu-alg>
        <emu-motivation>The definition here is unchanged, and still uses ToNumber rather than ToNumeric. This means that `+` will throw on Integers. The semantics here are designed to allow expressions of the form `+x` to always return Numbers, which is necessary to <a href="https://github.com/littledan/proposal-integer/blob/master/README.md#dont-break-asmjs">preserve assumptions made by asm.js</a>.</emu-motivation>
      </emu-clause>
    </emu-clause>

    <!-- es6num="12.5.10" -->
    <emu-clause id="sec-unary-minus-operator">
      <h1>Unary `-` Operator</h1>
      <emu-note>
        <p>The unary `-` operator converts its operand to Number type and then negates it. Negating *+0* produces *-0*, and negating *-0* produces *+0*.</p>
      </emu-note>

      <!-- es6num="12.5.10.1" -->
      <emu-clause id="sec-unary-minus-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UnaryExpression : `-` UnaryExpression</emu-grammar>
        <emu-alg>
          1. Let _expr_ be the result of evaluating |UnaryExpression|.
          1. Let _oldValue_ be ? <del>ToNumber</del><ins>ToNumeric</ins>(? GetValue(_expr_)).
          1. <del>If _oldValue_ is *NaN*, return *NaN*.</del>
          1. <del>Return the result of negating _oldValue_; that is, compute a Number with the same magnitude but opposite sign.</del>
          1. <ins>Let _T_ be Type(_oldValue_).</ins>
          1. </ins>Return ? _T_::minus(_T_::additiveZero, _oldValue_).</ins>
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <!-- es6num="12.5.11" -->
    <emu-clause id="sec-bitwise-not-operator">
      <h1>Bitwise NOT Operator ( `~` )</h1>

      <!-- es6num="12.5.11.1" -->
      <emu-clause id="sec-bitwise-not-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UnaryExpression : `~` UnaryExpression</emu-grammar>
        <emu-alg>
          1. Let _expr_ be the result of evaluating |UnaryExpression|.
          1. Let _oldValue_ be ? <del>ToInt32</del><ins>ToNumeric</ins>(? GetValue(_expr_)).
          1. <del>Return the result of applying bitwise complement to _oldValue_. The result is a signed 32-bit integer.</del>
          1. <ins>Return ? _T_::bitNOT(_oldValue_).</ins>
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-exp-operator">
    <h1>Exponentiation Operator</h1>
    <emu-clause id="sec-exp-operator-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>
        ExponentiationExpression : UpdateExpression `**` ExponentiationExpression
      </emu-grammar>
      <emu-alg>
        1. Let _left_ be the result of evaluating _UpdateExpression_.
        1. Let _leftValue_ be ? GetValue(_left_).
        1. Let _right_ be the result of evaluating _ExponentiationExpression_.
        1. Let _rightValue_ be ? GetValue(_right_).
        1. Let _base_ be ? <del>ToNumber</del><ins>ToNumeric</ins>(_leftValue_).
        1. Let _exponent_ be ? <del>ToNumber</del><ins>ToNumeric</ins>(_rightValue_).
        1. <del>Return the result of <emu-xref href="#sec-applying-the-exp-operator" title>Applying the ** operator</emu-xref> with _base_ and _exponent_ as specified in <emu-xref href="#sec-applying-the-exp-operator"></emu-xref>.</del>
        1. <ins>If Type(_base_) does not equal Type(_exponent_), throw a *TypeError* exception.</ins>
        1. <ins>Return ? Type(_base_)::exponentiate(_base_, _exponent_).</ins>
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <!-- es6num="12.6" -->
  <emu-clause id="sec-multiplicative-operators">
    <h1>Multiplicative Operators</h1>
    <!-- es6num="12.6.3" -->
    <emu-clause id="sec-multiplicative-operators-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>MultiplicativeExpression : MultiplicativeExpression MultiplicativeOperator ExponentiationExpression</emu-grammar>
      <emu-alg>
        1. Let _left_ be the result of evaluating |MultiplicativeExpression|.
        1. Let _leftValue_ be ? GetValue(_left_).
        1. Let _right_ be the result of evaluating |ExponentiationExpression|.
        1. Let _rightValue_ be ? GetValue(_right_).
        1. Let _lnum_ be ? <del>ToNumber</del><ins>ToNumeric</ins>(_leftValue_).
        1. Let _rnum_ be ? <del>ToNumber</del><ins>ToNumeric</ins>(_rightValue_).
        1. <del>Return the result of applying the |MultiplicativeOperator| (`*`, `/`, or `%`) to _lnum_ and _rnum_ as specified in <emu-xref href="#sec-applying-the-mul-operator"></emu-xref>, <emu-xref href="#sec-applying-the-div-operator"></emu-xref>, or <emu-xref href="#sec-applying-the-mod-operator"></emu-xref>.</del>
        1. <ins>If Type(_lnum_) does not equal Type(_rnum_), throw a *TypeError* exception.</ins>
        1. <ins>Let _T_ be Type(_lnum_).</ins>
        1. <ins>If |MultiplicativeOperator| is `*`, return _T_::multiply(_lnum_, _rnum_).</ins>
        1. <ins>If |MultiplicativeOperator| is `/`, return _T_::divide(_lnum_, _rnum_).</ins>
        1. <ins>Otherwise, |MultiplicativeOperator| is `%`; return _T_::remainder(_lnum_, _rnum_).</ins>
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <!-- es6num="12.7" -->
  <emu-clause id="sec-additive-operators">
    <h1>Additive Operators</h1>
    <emu-clause id="sec-addition-operator-plus">
      <h1>The Addition Operator ( `+` )</h1>
      <emu-note>
        <p>The addition operator either performs string concatenation or numeric addition.</p>
      </emu-note>

      <!-- es6num="12.7.3.1" -->
      <emu-clause id="sec-addition-operator-plus-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>AdditiveExpression : AdditiveExpression `+` MultiplicativeExpression</emu-grammar>
        <emu-alg>
          1. Let _lref_ be the result of evaluating |AdditiveExpression|.
          1. Let _lval_ be ? GetValue(_lref_).
          1. Let _rref_ be the result of evaluating |MultiplicativeExpression|.
          1. Let _rval_ be ? GetValue(_rref_).
          1. Let _lprim_ be ? ToPrimitive(_lval_).
          1. Let _rprim_ be ? ToPrimitive(_rval_).
          1. If Type(_lprim_) is String or Type(_rprim_) is String, then
            1. Let _lstr_ be ? ToString(_lprim_).
            1. Let _rstr_ be ? ToString(_rprim_).
            1. Return the String that is the result of concatenating _lstr_ and _rstr_.
          1. Let _lnum_ be ? <del>ToNumber</del><ins>ToNumeric</ins>(_lprim_).
          1. Let _rnum_ be ? <del>ToNumber</del><ins>ToNumeric</ins>(_rprim_).
          1. <del>Return the result of applying the addition operation to _lnum_ and _rnum_. See the Note below <emu-xref href="#sec-applying-the-additive-operators-to-numbers"></emu-xref>.</del>
          1. <ins>If Type(_lnum_) does not equal Type(_rnum_), throw a *TypeError* exception.</ins>
          1. <ins>Let _T_ be Type(_lnum_).</ins>
          1. <ins>Return _T_::add(_lnum_, _rnum_).</ins>
        </emu-alg>
        <emu-note>
          <p>No hint is provided in the calls to ToPrimitive in steps 5 and 6. All standard objects except Date objects handle the absence of a hint as if the hint Number were given; Date objects handle the absence of a hint as if the hint String were given. Exotic objects may handle the absence of a hint in some other manner.</p>
        </emu-note>
        <emu-note>
          <p>Step 7 differs from step 5 of the Abstract Relational Comparison algorithm, by using the logical-or operation instead of the logical-and operation.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <!-- es6num="12.7.4" -->
    <emu-clause id="sec-subtraction-operator-minus">
      <h1>The Subtraction Operator ( `-` )</h1>

      <!-- es6num="12.7.4.1" -->
      <emu-clause id="sec-subtraction-operator-minus-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>AdditiveExpression : AdditiveExpression `-` MultiplicativeExpression</emu-grammar>
        <emu-alg>
          1. Let _lref_ be the result of evaluating |AdditiveExpression|.
          1. Let _lval_ be ? GetValue(_lref_).
          1. Let _rref_ be the result of evaluating |MultiplicativeExpression|.
          1. Let _rval_ be ? GetValue(_rref_).
          1. Let _lnum_ be ? <del>ToNumber</del><ins>ToNumeric</ins>(_lval_).
          1. Let _rnum_ be ? <del>ToNumber</del><ins>ToNumeric</ins>(_rval_).
          1. <del>Return the result of applying the subtraction operation to _lnum_ and _rnum_. See the note below <emu-xref href="#sec-applying-the-additive-operators-to-numbers"></emu-xref>.</del>
          1. <ins>If Type(_lnum_) does not equal Type(_rnum_), throw a *TypeError* exception.</ins>
          1. <ins>Let _T_ be Type(_lnum_).</ins>
          1. <ins>Return _T_::subtract(_lnum_, _rnum_).</ins>
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <!-- es6num="12.8" -->
  <emu-clause id="sec-bitwise-shift-operators">
    <h1>Bitwise Shift Operators</h1>

    <!-- es6num="12.8.3" -->
    <emu-clause id="sec-left-shift-operator">
      <h1>The Left Shift Operator ( `&lt;&lt;` )</h1>
      <emu-note>
        <p>Performs a bitwise left shift operation on the left operand by the amount specified by the right operand.</p>
      </emu-note>

      <!-- es6num="12.8.3.1" -->
      <emu-clause id="sec-left-shift-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>ShiftExpression : ShiftExpression `&lt;&lt;` AdditiveExpression</emu-grammar>
        <emu-alg>
          1. Let _lref_ be the result of evaluating |ShiftExpression|.
          1. Let _lval_ be ? GetValue(_lref_).
          1. Let _rref_ be the result of evaluating |AdditiveExpression|.
          1. Let _rval_ be ? GetValue(_rref_).
          1. Let _lnum_ be ? <del>ToInt32</del><ins>ToNumeric</ins>(_lval_).
          1. Let _rnum_ be ? <del>ToUint32</del><ins>ToNumeric</ins>(_rval_).
          1. <del>Let _shiftCount_ be the result of masking out all but the least significant 5 bits of _rnum_, that is, compute _rnum_ &amp; 0x1F.</del>
          1. <del>Return the result of left shifting _lnum_ by _shiftCount_ bits. The result is a signed 32-bit integer.</del>
          1. <ins>If Type(_lnum_) does not equal Type(_rnum_), throw a *TypeError* exception.</ins>
          1. <ins>Let _T_ be Type(_lnum_).</ins>
          1. <ins>Return _T_::leftShift(_lnum_, _rnum_).</ins>
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <!-- es6num="12.8.4" -->
    <emu-clause id="sec-signed-right-shift-operator">
      <h1>The Signed Right Shift Operator ( `&gt;&gt;` )</h1>
      <emu-note>
        <p>Performs a sign-filling bitwise right shift operation on the left operand by the amount specified by the right operand.</p>
      </emu-note>

      <!-- es6num="12.8.4.1" -->
      <emu-clause id="sec-signed-right-shift-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>ShiftExpression : ShiftExpression `&gt;&gt;` AdditiveExpression</emu-grammar>
        <emu-alg>
          1. Let _lref_ be the result of evaluating |ShiftExpression|.
          1. Let _lval_ be ? GetValue(_lref_).
          1. Let _rref_ be the result of evaluating |AdditiveExpression|.
          1. Let _rval_ be ? GetValue(_rref_).
          1. Let _lnum_ be ? <del>ToInt32</del><ins>ToNumeric</ins>(_lval_).
          1. Let _rnum_ be ? <del>ToUint32</del><ins>ToNumeric</ins>(_rval_).
          1. <del>Let _shiftCount_ be the result of masking out all but the least significant 5 bits of _rnum_, that is, compute _rnum_ &amp; 0x1F.</del>
          1. <del>Return the result of performing a sign-extending right shift of _lnum_ by _shiftCount_ bits. The most significant bit is propagated. The result is a signed 32-bit integer.</del>
          1. <ins>If Type(_lnum_) does not equal Type(_rnum_), throw a *TypeError* exception.</ins>
          1. <ins>Let _T_ be Type(_lnum_).</ins>
          1. <ins>Return _T_::rightShift(_lnum_, _rnum_).</ins>
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <!-- es6num="12.8.5" -->
    <emu-clause id="sec-unsigned-right-shift-operator">
      <h1>The Unsigned Right Shift Operator ( `&gt;&gt;&gt;` )</h1>
      <emu-note>
        <p>Performs a zero-filling bitwise right shift operation on the left operand by the amount specified by the right operand.</p>
      </emu-note>

      <!-- es6num="12.8.5.1" -->
      <emu-clause id="sec-unsigned-right-shift-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>ShiftExpression : ShiftExpression `&gt;&gt;&gt;` AdditiveExpression</emu-grammar>
        <emu-alg>
          1. Let _lref_ be the result of evaluating |ShiftExpression|.
          1. Let _lval_ be ? GetValue(_lref_).
          1. Let _rref_ be the result of evaluating |AdditiveExpression|.
          1. Let _rval_ be ? GetValue(_rref_).
          1. Let _lnum_ be ? <del>ToInt32</del><ins>ToNumeric</ins>(_lval_).
          1. Let _rnum_ be ? <del>ToUint32</del><ins>ToNumeric</ins>(_rval_).
          1. <del>Let _shiftCount_ be the result of masking out all but the least significant 5 bits of _rnum_, that is, compute _rnum_ &amp; 0x1F.</del>
          1. <del>Return the result of performing a zero-filling right shift of _lnum_ by _shiftCount_ bits. Vacated bits are filled with zero. The result is an unsigned 32-bit integer.</del>
          1. <ins>If Type(_lnum_) does not equal Type(_rnum_), throw a *TypeError* exception.</ins>
          1. <ins>Let _T_ be Type(_lnum_).</ins>
          1. <ins>Return _T_::unsignedRightShift(_lnum_, _rnum_).</ins>
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <!-- es6num="12.11" -->
  <emu-clause id="sec-binary-bitwise-operators">
    <h1>Binary Bitwise Operators</h1>

    <!-- es6num="12.11.3" -->
    <emu-clause id="sec-binary-bitwise-operators-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <p>The production <emu-grammar>A : A @ B</emu-grammar>, where @ is one of the bitwise operators in the productions above, is evaluated as follows:</p>
      <emu-alg>
        1. Let _lref_ be the result of evaluating _A_.
        1. Let _lval_ be ? GetValue(_lref_).
        1. Let _rref_ be the result of evaluating _B_.
        1. Let _rval_ be ? GetValue(_rref_).
        1. Let _lnum_ be ? <del>ToInt32</del><ins>ToNumeric</ins>(_lval_).
        1. Let _rnum_ be ? <del>ToUint32</del><ins>ToNumeric</ins>(_rval_).
        1. <ins>If Type(_lnum_) does not equal Type(_rnum_), throw a *TypeError* exception.</ins>
        1. <ins>Let _T_ be Type(_lnum_).</ins>
        1. <ins>If @ is `&amp;`, return _T_::bitwiseAND(_lnum_, _rnum_).</ins>
        1. <ins>If @ is `|`, return _T_::bitwiseOR(_lnum_, _rnum_).</ins>
        1. <ins>Otherwise, @ is `^`; return _T_::bitwiseXOR(_lnum_, _rnum_).</ins>
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-integer-object">
  <h1>Integer Objects</h1>
    <emu-clause id="sec-integer-constructor">
      <h1>The Integer Constructor</h1>
      <p>The Integer constructor is the <dfn>%Integer%</dfn> intrinsic object and the initial value of the `Integer` property of the global object. When `Integer` is called as a function, it performs a type conversion.</p>

      <emu-clause id="sec-is-safe-integer" aoid="IsSafeInteger">
        <h1>IsSafeInteger ( _number_ )</h1>
        <emu-alg>
          1. Assert: Type(_number_) is Number.
          1. If _number_ is *NaN*, *+&infin;*, or *-&infin;*, return *false*.
          1. Let _integer_ be ToInteger(_number_).
          1. If _integer_ is not equal to _number_, return *false*.
          1. If abs(_integer_) &le; 2<sup>53</sup>-1, return *true*.
          1. Otherwise, return *false*.
        </emu-alg>
        <emu-integration-plans>Number.isSafeInteger will be refactored to call this abstract algorithm.</emu-integration-plans>
      </emu-clause>

      <emu-clause id="sec-number-to-integer" aoid="NumberToInteger">
        <h1>NumberToInteger ( _number_ )</h1>
        <emu-alg>
          1. Assert: Type(_number_) is Number.
          1. If IsSafeInteger(_number_) is *false*, throw a *RangeError* exception.
          1. Let _int_ be the mathematical value that is the same sign as _number_ and whose magnitude is floor(abs(_number_)).
          1. Return an Integer value representing _int_.
        </emu-alg>
        <emu-issue>Throwing on unsafe integer inputs is discussed <a href="https://github.com/tc39/proposal-integer/issues/15">in this issue</a>.</emu-issue>
      </emu-clause>

      <emu-clause id="sec-integer-constructor-number-value">
        <h1>Integer ( _value_ )</h1>
        <p>When `Integer` is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If NewTarget is not *undefined*, throw a *TypeError* exception.
          1. Let _prim_ be ? ToPrimitive(_value_).
          1. Return the value that _prim_ correspond to in <emu-xref href="#table-to-integer"></emu-xref>
        </emu-alg>
        <emu-issue>Integer wrapped objects cannot be created using `new` on Integer due to the throw in line 1; they can be created explicitly with `Object()` however. This follows a precedent from SIMD.js. <a href="https://github.com/littledan/proposal-integer/issues/13">An open issue</a> discusses whether this is appropriate.</emu-issue>
        <emu-table id="table-to-integer" caption="Integer Conversions">
        <table>
          <tbody>
          <tr>
            <th>
              Argument Type
            </th>
            <th>
              Result
            </th>
          </tr>
          <tr>
            <td>
              Undefined
            </td>
            <td>
              Throw a *TypeError* exception.
              <emu-issue>Alternatively, we could return `0n` here and several of the below cases; see <a href="https://github.com/littledan/proposal-integer/issues/15">this issue</a> for discussion</a>.
            </td>
          </tr>
          <tr>
            <td>
              Null
            </td>
            <td>
              Throw a *TypeError* exception.
            </td>
          </tr>
          <tr>
            <td>
              Boolean
            </td>
            <td>
              Return `1n` if _prim_ is *true* and `0n` if _prim_ is *false*.
            </td>
          </tr>
          <tr>
            <td>
              Number
            </td>
            <td>
              Return NumberToInteger(_prim_).
            </td>
          </tr>
          <tr>
            <td>
              String
            </td>
            <td>
              Apply the algorithm in <emu-xref href="#sec-tonumber-applied-to-the-string-type"></emu-xref> with the following changes:
              <ul>
                <li>If the grammar fails to apply, throw a *SyntaxError* rather than returning *NaN*.</li>
                <li>Replace the |StrDecimalLiteral| production with |DecimalDigits| to not allow decimal points or exponents.</li>
                <li>Return the Integer which exactly corresponds to the MV, rather than rounding to a Number.</li>
              </ul>
            </td>
          </tr>
          <tr>
            <td>
              Symbol
            </td>
            <td>
              Throw a *TypeError* exception.
            </td>
          </tr>
          </tbody>
        </table>
        </emu-table>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-integer-constructor">
      <h1>Properties of the Integer Constructor</h1>
      <p>The value of the [[Prototype]] internal slot of the Integer constructor is the intrinsic object %FunctionPrototype%.</p>
      <p>The Integer constructor has the following properties:</p>

      <emu-clause id="sec-parseint-string-radix">
        <h1>parseInt ( _string_, _radix_ )</h1>
        <p>The `parseInt` function produces an Integer value dictated by interpretation of the contents of the _string_ argument according to the specified _radix_.</p>
        <p>The algorithm is the same as <emu-xref href="#sec-parseint-string-radix"></emu-xref> but with the following edits:</p>
        <ul>
          <li>For all cases which result in returning *NaN*, throw a *SyntaxError* exception.</li>
          <li>For all cases which result in returning *-0*, return `0n`.</li>
          <li>Replace the second to last step, which casts _mathInt_ to a Number, with casting _mathInt_ to an Integer.</li>
        </ul>
      </emu-clause>

      <!-- es6num="20.1.2.2" -->
      <emu-clause id="sec-integer.asuintn">
        <h1>Integer.asUintN ( _integer_, _bits_ )</h1>
        <p>When the `Integer.asUintN` is called with two argument _bits_ and _integer_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_integer_) is not _integer_, return *false*.
          1. Let _bits_ be ? ToIndex(_bits_).
          1. Return an Integer representing _integer_ modulo 2<sup>_bits_</sup>.
        </emu-alg>
      </emu-clause>

      <!-- es6num="20.1.2.3" -->
      <emu-clause id="sec-integer.asintn">
        <h1>Number.asIntN ( _bits_, _integer_ )</h1>
        <p>When the `Integer.asIntN` is called with two argument _bits_ and _integer_, the following steps are taken:</p>
        <emu-alg>
          1. If Type(_integer_) is not _integer_, return *false*.
          1. Let _bits_ be ? ToIndex(_bits_).
          1. Let _mod_ be an Integer representing _integer_ modulo 2<sup>_bits_</sup>.
          1. If _mod_ &ge; 2<sup>_bits_ - 1</sup>, return _mod_ - 2<sup>_bits_</sup>; otherwise, return _mod_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-integer.prototype">
        <h1>Integer.prototype</h1>
        <p>The initial value of `Integer.prototype` is the intrinsic object %IntegerPrototype%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-integer-prototype-object">
      <h1>Properties of the Integer Prototype Object</h1>
      <p>The Integer prototype object is the intrinsic object <dfn>%IntegerPrototype%</dfn>. The Integer prototype object is an ordinary object. The Integer prototype is not an Integer object; it does not have a [[IntegerData]] internal slot.</p>
      <p>The value of the [[Prototype]] internal slot of the Integer prototype object is the intrinsic object %ObjectPrototype%.</p>
      <p>The abstract operation thisIntegerValue(_value_) performs the following steps:</p>
      <emu-alg>
        1. If Type(_value_) is Integer, return _value_.
        1. If Type(_value_) is Object and _value_ has a [[IntegerData]] internal slot, then
          1. Assert: _value_.[[IntegerData]] is an Integer value.
          1. Return _value_.[[IntegerData]].
        1. Throw a *TypeError* exception.
      </emu-alg>
      <p>The phrase &ldquo;this Integer value&rdquo; within the specification of a method refers to the result returned by calling the abstract operation thisNumberValue with the *this* value of the method invocation passed as the argument.</p>

      <!-- es6num="20.1.3.1" -->
      <emu-clause id="sec-integer.prototype.constructor">
        <h1>Integer.prototype.constructor</h1>
        <p>The initial value of `Integer.prototype.constructor` is the intrinsic object %Integer%.</p>
      </emu-clause>

      <!-- es6num="20.1.3.4" -->
      <emu-clause id="sec-integer.prototype.tolocalestring">
        <h1>Integer.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `Integer.prototype.toLocaleString` method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `toLocaleString` method is used.</p>
        <p>Produces a String value that represents this Integer value formatted according to the conventions of the host environment's current locale. This function is implementation-dependent, and it is permissible, but not encouraged, for it to return the same thing as `toString`.</p>
        <p>The meanings of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.</p>
        <emu-issue>It's not clear if existing platform internationalization libraries support formatting arbitrary precision integers. <a href="https://github.com/littledan/proposal-integer/issues/16">Should we include this method, given that?</a></emu-issue>
      </emu-clause>

      <!-- es6num="20.1.3.6" -->
      <emu-clause id="sec-integer.prototype.tostring">
        <h1>Integer.prototype.toString ( [ _radix_ ] )</h1>
        <emu-note>
          <p>The optional _radix_ should be an integer value in the inclusive range 2 to 36. If _radix_ not present or is *undefined* the Number 10 is used as the value of _radix_.</p>
        </emu-note>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _x_ be ? thisIntegerValue(*this* value).
          1. If _radix_ is not present, let _radixNumber_ be 10.
          1. Else if _radix_ is *undefined*, let _radixNumber_ be 10.
          1. Else, let _radixNumber_ be ? ToInteger(_radix_).
          1. If _radixNumber_ &lt; 2 or _radixNumber_ &gt; 36, throw a *RangeError* exception.
          1. If _radixNumber_ = 10, return ! ToString(_x_).
          1. Return the String representation of this Number value using the radix specified by _radixNumber_. Letters `a`-`z` are used for digits with values 10 through 35. The precise algorithm is implementation-dependent, however the algorithm should be a generalization of that specified in <emu-xref href="#sec-tostring-applied-to-the-integer-type"></emu-xref>.
        </emu-alg>
        <p>The `toString` function is not generic; it throws a *TypeError* exception if its *this* value is not a Number or a Number object. Therefore, it cannot be transferred to other kinds of objects for use as a method.</p>
      </emu-clause>

      <!-- es6num="20.1.3.7" -->
      <emu-clause id="sec-integer.prototype.valueof">
        <h1>Integer.prototype.valueOf ( )</h1>
        <emu-alg>
          1. Return ? thisIntegerValue(*this* value).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

<emu-clause id="sec-modifications">
  <h1>Modified algorithms</h1>
      <!-- es6num="24.3.2.1" -->
      <emu-clause id="sec-serializejsonproperty" aoid="SerializeJSONProperty">
        <h1>Runtime Semantics: SerializeJSONProperty ( _key_, _holder_ )</h1>
        <p>The abstract operation SerializeJSONProperty with arguments _key_, and _holder_ has access to _ReplacerFunction_ from the invocation of the `stringify` method. Its algorithm is as follows:</p>
        <emu-alg>
          1. Let _value_ be ? Get(_holder_, _key_).
          1. If Type(_value_) is Object, then
            1. Let _toJSON_ be ? Get(_value_, `"toJSON"`).
            1. If IsCallable(_toJSON_) is *true*, then
              1. Set _value_ to ? Call(_toJSON_, _value_, &laquo; _key_ &raquo;).
          1. If _ReplacerFunction_ is not *undefined*, then
            1. Set _value_ to ? Call(_ReplacerFunction_, _holder_, &laquo; _key_, _value_ &raquo;).
          1. If Type(_value_) is Object, then
            1. If _value_ has a [[NumberData]] internal slot, then
              1. Set _value_ to ? ToNumber(_value_).
            1. Else if _value_ has a [[StringData]] internal slot, then
              1. Set _value_ to ? ToString(_value_).
            1. Else if _value_ has a [[BooleanData]] internal slot, then
              1. Set _value_ to _value_.[[BooleanData]].
            1. <ins>Else if _value_ has a [[IntegerData]] internal slot, then</ins>
              1. <ins>Set _value_ to _value_.[[IntegerData]].</ins>
          1. If _value_ is *null*, return `"null"`.
          1. If _value_ is *true*, return `"true"`.
          1. If _value_ is *false*, return `"false"`.
          1. If Type(_value_) is String, return QuoteJSONString(_value_).
          1. If Type(_value_) is Number, then
            1. If _value_ is finite, return ! ToString(_value_).
            1. Else, return `"null"`.
          1. If Type(_value_) is Object and IsCallable(_value_) is *false*, then
            1. Let _isArray_ be ? IsArray(_value_).
            1. If _isArray_ is *true*, return ? SerializeJSONArray(_value_).
            1. Else, return ? SerializeJSONObject(_value_).
          1. <ins>If Type(_value_) is Integer, throw a *TypeError* exception.</ins>
          1. Return *undefined*.
        </emu-alg>
      </emu-clause>

      <!-- es6num="20.1.1.1" -->
      <emu-clause id="sec-number-constructor-number-value">
        <h1>Number ( _value_ )</h1>
        <p>When `Number` is called with argument _number_, the following steps are taken:</p>
        <emu-alg>
          1. If no arguments were passed to this function invocation, let _n_ be *+0*.
          1. Else,
            1. Let _prim_ be ? ToPrimitive(_value_).
            1. If Type(_prim_) is Integer, let _n_ be the Number value for _prim_.
            1. Otherwise, let _n_ be ? ToNumber(_value_).
          1. If NewTarget is *undefined*, return _n_.
          1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, `"%NumberPrototype%"`, &laquo; [[NumberData]] &raquo;).
          1. Set _O_.[[NumberData]] to _n_.
          1. Return _O_.
        </emu-alg>
        <emu-note>See <emu-xref href="#sec-ecmascript-language-types-number-type"></emu-xref> in the second-to-last paragraph for the definition of the phrase "The Number value for _integer_".</emu-note>
        <emu-integration-plans>That paragraph should possibly be refactored into a separate abstract operation; see <a href="https://github.com/littledan/proposal-integer/issues/10">this bug</a> for more discussion about the integration of different numeric types and casting operations between them.</emu-integration-plans>
      </emu-clause>
</emu-clause>

<emu-clause id="sec-typedarrays-and-dataview">
  <h1>TypedArrays and DataViews</h1>
  Integer is integrated into TypedArray, DataView, SharedArrayBuffer and Atomics by providing Int64 and Uint64 access as represented by Integers on the ECMAScript side.

  <emu-clause id="sec-typedarray-objects">
    <h1>TypedArray Objects</h1>
    <emu-table id="table-49" caption="The TypedArray Constructors">
      <table>
        <tbody>
        <tr>
          <th>
            Constructor Name and Intrinsic
          </th>
          <th>
            Element Type
          </th>
          <th>
            Element Size
          </th>
          <th>
            Conversion Operation
          </th>
          <th>
            Description
          </th>
          <th>
            Equivalent C Type
          </th>
        </tr>
        <tr>
          <td>
            <ins>Int64Array</ins>
            <br>
            <ins>%Int64Array%</ins>
          </td>
          <td>
            <ins>Int64</ins>
          </td>
          <td>
            <ins>8</ins>
          </td>
          <td>
            <ins>ToInt64</ins>
          </td>
          <td>
            <ins>64-bit 2's complement signed integer</ins>
          </td>
          <td>
            <ins>signed long long</ins>
          </td>
        </tr>
        <tr>
          <td>
            <ins>Uint64Array</ins>
            <br>
            <ins>%Uint64Array%</ins>
          </td>
          <td>
            <ins>Uint64</ins>
          </td>
          <td>
            <ins>8</ins>
          </td>
          <td>
            <ins>ToUint64</ins>
          </td>
          <td>
            <ins>64-bit unsigned integer</ins>
          </td>
          <td>
            <ins>unsigned long long</ins>
          </td>
        </tr>
        </tbody>
      </table>
    </emu-table>
  </emu-clause>
  <emu-clause id="sec-to-int64" aoid="ToInt64">
    <h1>ToInt64 ( _argument_ )</h1>
    <p>The abstract operation ToInt64 converts _argument_ to one of 2<sup>64</sup> integer values in the range -2<sup>63</sup> through 2<sup>63</sup>-1, inclusive. This abstract operation functions as follows:</p>
    <emu-alg>
      1. Let _n_ be ? ToNumeric(_argument_).
      1. If Type(_n_) is not Integer, throw a *TypeError*.
      1. Let _int64bit_ be _n_ modulo 2<sup>64</sup>.
      1. If _int64bit_ &ge; 2<sup>64</sup>, return _int64bit_ - 2<sup>63</sup>; otherwise return _int64bit_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-to-uint64" aoid="ToUint64">
    <h1>ToUint64 ( _argument_ )</h1>
    <p>The abstract operation ToUint64 converts _argument_ to one of 2<sup>64</sup> integer values in the range 0 through 2<sup>64</sup>-1, inclusive. This abstract operation functions as follows:</p>
    <emu-alg>
      1. Let _n_ be ? ToNumeric(_argument_).
      1. If Type(_n_) is not Integer, throw a *TypeError*.
      1. Let _int64bit_ be _n_ modulo 2<sup>64</sup>.
      1. Return _int64bit_.
    </emu-alg>
  </emu-clause>

      <emu-clause id="sec-rawbytestonumber" aoid="RawBytesToNumber">
        <h1>RawBytesToNumber( _type_, _rawBytes_, _isLittleEndian_ )</h1>
        <p>The abstract operation RawBytesToNumber takes three parameters, a String _type_, a List _rawBytes_, and a Boolean _isLittleEndian_. This operation performs the following steps:</p>
        <emu-alg>
          1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for Element Type _type_.
          1. If _isLittleEndian_ is *false*, reverse the order of the elements of _rawBytes_.
          1. If _type_ is `"Float32"`, then
            1. Let _value_ be the byte elements of _rawBytes_ concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2008 binary32 value.
            1. If _value_ is an IEEE 754-2008 binary32 NaN value, return the *NaN* Number value.
            1. Return the Number value that corresponds to _value_.
          1. If _type_ is `"Float64"`, then
            1. Let _value_ be the byte elements of _rawBytes_ concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2008 binary64 value.
            1. If _value_ is an IEEE 754-2008 binary64 NaN value, return the *NaN* Number value.
            1. Return the Number value that corresponds to _value_.
          1. If the first code unit of _type_ is `"U"`, then
            1. Let _intValue_ be the byte elements of _rawBytes_ concatenated and interpreted as a bit string encoding of an unsigned little-endian binary number.
          1. Else,
            1. Let _intValue_ be the byte elements of _rawBytes_ concatenated and interpreted as a bit string encoding of a binary little-endian 2's complement number of bit length _elementSize_ &times; 8.
          1. <ins>If _type_ is `"Uint64"` or `"Int64"`, return the Integer value that corresponds to _intValue_.</ins>
          1. <ins>Otherwise, </ins>return the Number value that corresponds to _intValue_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-numbertorawbytes" aoid="NumberToRawBytes">
        <h1>NumberToRawBytes( _type_, _value_, _isLittleEndian_ )</h1>
        <p>The abstract operation NumberToRawBytes takes three parameters, a String _type_, a <ins>Integer or </ins>Number _value_, and a Boolean _isLittleEndian_. This operation performs the following steps:</p>
        <emu-alg>
          1. If _type_ is `"Float32"`, then
            1. Set _rawBytes_ to a List containing the 4 bytes that are the result of converting _value_ to IEEE 754-2008 binary32 format using &ldquo;Round to nearest, ties to even&rdquo; rounding mode. If _isLittleEndian_ is *false*, the bytes are arranged in big endian order. Otherwise, the bytes are arranged in little endian order. If _value_ is *NaN*, _rawValue_ may be set to any implementation chosen IEEE 754-2008 binary32 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable *NaN* value.
          1. Else if _type_ is `"Float64"`, then
            1. Set _rawBytes_ to a List containing the 8 bytes that are the IEEE 754-2008 binary64 format encoding of _value_. If _isLittleEndian_ is *false*, the bytes are arranged in big endian order. Otherwise, the bytes are arranged in little endian order. If _value_ is *NaN*, _rawValue_ may be set to any implementation chosen IEEE 754-2008 binary64 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable *NaN* value.
          1. Else,
            1. Let _n_ be the Number value of the Element Size specified in <emu-xref href="#table-49"></emu-xref> for Element Type _type_.
            1. Let _convOp_ be the abstract operation named in the Conversion Operation column in <emu-xref href="#table-49"></emu-xref> for Element Type _type_.
            1. Let _intValue_ be _convOp_(_value_) <ins>treated as a mathematical value, whether the result is an Integer or Number</ins>.
            1. If _intValue_ &ge; 0, then
              1. Let _rawBytes_ be a List containing the _n_-byte binary encoding of _intValue_. If _isLittleEndian_ is *false*, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.
            1. Else,
              1. Let _rawBytes_ be a List containing the _n_-byte binary 2's complement encoding of _intValue_. If _isLittleEndian_ is *false*, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.
          1. Return _rawBytes_.
        </emu-alg>
      </emu-clause>

      <!-- es6num="9.4.5.9" -->
      <emu-clause id="sec-integerindexedelementset" aoid="IntegerIndexedElementSet">
        <h1>IntegerIndexedElementSet ( _O_, _index_, _value_ )</h1>
        <p>The abstract operation IntegerIndexedElementSet with arguments _O_, _index_, and _value_ performs the following steps:</p>
        <emu-alg>
          1. Assert: Type(_index_) is Number.
          1. Assert: _O_ is an Object that has [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal slots.
          1. Let _arrayTypeName_ be the String value of _O_.[[TypedArrayName]].
          1. Let _elementType_ be the String value of the Element Type value in <emu-xref href="#table-49"></emu-xref> for _arrayTypeName_.
          1. Let _numValue_ be ? <del>ToNumber</del><ins>ToNumeric</ins>(_value_).
          1. <ins>If _elementType_ is `"Int64"` or `"Uint64"`,</ins>
            1. <ins>If Type(_numValue_) is not Integer, throw a *TypeError*.</ins>
          1. <ins>Otherwise, if Type(_numValue_) is not Number, throw a *TypeError*.</ins>
          1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
          1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
          1. If IsInteger(_index_) is *false*, return *false*.
          1. If _index_ = *-0*, return *false*.
          1. Let _length_ be _O_.[[ArrayLength]].
          1. If _index_ &lt; 0 or _index_ &ge; _length_, return *false*.
          1. Let _offset_ be _O_.[[ByteOffset]].
          1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for _arrayTypeName_.
          1. Let _indexedPosition_ be (_index_ &times; _elementSize_) + _offset_.
          1. Perform SetValueInBuffer(_buffer_, _indexedPosition_, _elementType_, _numValue_, *true*, `"Unordered"`).
          1. Return *true*.
        </emu-alg>
        <emu-integration-plans>Several other functions and abstract algorithms need similar treatment; for example, SetViewValue and Atomics.store. Other places in the specification need changes to their assertions, such as the assertion in SetValueInBuffer that the _value_ is passed is a Number (instead, the assertion should assert Integer for Int64/Uint64Array).</emu-integration-plans>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getint64">
        <h1>DataView.prototype.getInt64 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>When the `getInt64` method is called with argument _byteOffset_ and optional argument _littleEndian_, the following steps are taken:</p>
        <emu-alg>
          1. Let _v_ be the *this* value.
          1. If _littleEndian_ is not present, let _littleEndian_ be *undefined*.
          1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, `"Int64"`).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getuint64">
        <h1>DataView.prototype.getUint64 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>When the `getUint64` method is called with argument _byteOffset_ and optional argument _littleEndian_, the following steps are taken:</p>
        <emu-alg>
          1. Let _v_ be the *this* value.
          1. If _littleEndian_ is not present, let _littleEndian_ be *undefined*.
          1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, `"Uint64"`).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setint64">
        <h1>DataView.prototype.setInt64 ( _byteOffset_, _value_ )</h1>
        <p>When the `setInt64` method is called with arguments _byteOffset_ and _value_, the following steps are taken:</p>
        <emu-alg>
          1. Let _v_ be the *this* value.
          1. Return ? SetViewValue(_v_, _byteOffset_, *true*, `"Int64"`, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setuint64">
        <h1>DataView.prototype.setUint64 ( _byteOffset_, _value_ )</h1>
        <p>When the `setUint64` method is called with arguments _byteOffset_ and _value_, the following steps are taken:</p>
        <emu-alg>
          1. Let _v_ be the *this* value.
          1. Return ? SetViewValue(_v_, _byteOffset_, *true*, `"Uint64"`, _value_).
        </emu-alg>
      </emu-clause>

</emu-clause>
